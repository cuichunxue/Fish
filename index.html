<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æµ·ã®å¤§å†’é™ºï¼é­šã®ã‚¨ãƒœãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(180deg, #0077be 0%, #003f5c 100%);
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: pointer;
            background: linear-gradient(180deg, 
                rgba(135, 206, 250, 0.8) 0%, 
                rgba(70, 130, 180, 0.9) 30%, 
                rgba(25, 25, 112, 0.95) 70%, 
                rgba(0, 0, 139, 1) 100%);
        }

        .ui-panel {
            position: absolute;
            background: rgba(0, 50, 100, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 18px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        #scorePanel {
            top: 20px;
            left: 20px;
        }

        #levelPanel {
            top: 20px;
            right: 20px;
        }

        #infoPanel {
            bottom: 20px;
            left: 20px;
            max-width: 300px;
            font-size: 14px;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 30, 60, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #00ffff, #0080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .screen p {
            font-size: 20px;
            margin-bottom: 30px;
            max-width: 600px;
        }

        .button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        #tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 50, 100, 0.9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 18px;
            text-align: center;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .creature-info {
            position: absolute;
            background: rgba(0, 50, 100, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            display: none;
        }

        #joystick {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            backdrop-filter: blur(10px);
            z-index: 1000;
            touch-action: none;
            display: none; /* åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º */
        }

        #joystickKnob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.4);
        }

        #joystickKnob.active {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.6);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="scorePanel" class="ui-panel">
            ã‚¹ã‚³ã‚¢: <span id="scoreValue">0</span>
        </div>
        
        <div id="levelPanel" class="ui-panel">
            ãƒ¬ãƒ™ãƒ«: <span id="levelValue">1</span>
        </div>
        
        <div id="infoPanel" class="ui-panel">
            <div id="playerInfo">ğŸ  å°ã•ãªé­š</div>
            <div id="healthBar" style="margin-top: 5px;">
                ä½“åŠ›: <div style="background: #333; height: 8px; border-radius: 4px; overflow: hidden; width: 100px; display: inline-block;">
                    <div id="healthFill" style="background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00); height: 100%; width: 100%; transition: width 0.3s;"></div>
                </div>
            </div>
            <div id="oxygenBar" style="margin-top: 5px;">
                é…¸ç´ : <div style="background: #333; height: 8px; border-radius: 4px; overflow: hidden; width: 100px; display: inline-block;">
                    <div id="oxygenFill" style="background: linear-gradient(90deg, #00ff00, #ffff00); height: 100%; width: 100%; transition: width 0.3s;"></div>
                </div>
            </div>
            <div id="invincibilityStatus" style="margin-top: 5px; color: #FFD700; display: none;">
                â­ ç„¡æ•µæ™‚é–“ä¸­ï¼
            </div>
        </div>
        
        <div id="startScreen" class="screen">
            <h1>ğŸŒŠ æµ·ã®å¤§å†’é™ºï¼ ğŸŸ</h1>
            <p>ç¾ã—ã„æµ·ã§æ§˜ã€…ãªæµ·æ´‹ç”Ÿç‰©ã¨å‡ºä¼šã„ã€æˆé•·ã—ã¦ã„ã“ã†ï¼<br>
            ã‚¿ã‚³ã®è¶³ã€ã‚¤ã‚«ã®å¢¨ã€ã‚¯ãƒ©ã‚²ã®æ¯’ãªã©ã€ãã‚Œãã‚Œã®ç‰¹å¾´ã‚’æ¥½ã—ã‚‚ã†ï¼</p>
            <button id="startButton" class="button">ğŸš€ å†’é™ºé–‹å§‹ï¼</button>
        </div>
        
        <div id="gameOverScreen" class="screen">
            <h1>ğŸŒŠ å†’é™ºçµ‚äº† ğŸŒŠ</h1>
            <p id="finalScore">ã‚¹ã‚³ã‚¢: 0</p>
            <p id="achievements"></p>
            <button id="restartButton" class="button">ğŸ”„ ã‚‚ã†ä¸€åº¦å†’é™º</button>
        </div>
        
        <div id="tutorial">
            <p>ğŸ–±ï¸ ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦æ³³ã”ã†ï¼<br>
            ğŸ® ã¾ãŸã¯å³ä¸‹ã®ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã§æ“ä½œï¼<br>
            å°ã•ãªç”Ÿãç‰©ã‚’é£Ÿã¹ã¦æˆé•·ã—ã‚ˆã†ï¼</p>
        </div>

        <div id="creatureInfo" class="creature-info"></div>

        <!-- ãƒãƒ¼ãƒãƒ£ãƒ«ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ -->
        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
    </div>

    <script>
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        const GameState = {
            score: 0,
            level: 1,
            gameRunning: false,
            player: null,
            entities: [],
            particles: [],
            bubbles: [],
            lastSpawnTime: 0,
            animationId: null,
            oxygen: 100,
            timeOfDay: 0, // 0-1ã§æ™‚é–“ã‚’è¡¨ç¾
            currentWave: 0,
            waveIntensity: 0,
            specialEvents: [],
            achievements: [],
            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯çŠ¶æ…‹
            joystick: {
                active: false,
                centerX: 0,
                centerY: 0,
                knobX: 0,
                knobY: 0,
                inputX: 0,
                inputY: 0,
                maxDistance: 40
            },
            // æ–°ã—ã„çŠ¶æ…‹
            isInvincible: false,
            invincibilityTime: 0,
            eatingAnimations: [],
            bloodEffects: []
        };

        // æµ·æ´‹ç”Ÿç‰©ã®å®šç¾©
        const CreatureTypes = {
            // ãƒ¬ãƒ™ãƒ«1-2ï¼šå°å‹ç”Ÿç‰©
            PLANKTON: {
                name: 'ãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³',
                emoji: 'ğŸ¦ ',
                size: 4,
                speed: 0.5,
                value: 5,
                behavior: 'drifting',
                description: 'æµ·ã®åŸºæœ¬çš„ãªé£Ÿã¹ç‰©ã€‚æ „é¤Šã¯ã‚ãšã‹ã€‚',
                color: ['#90EE90', '#98FB98', '#00FF7F'],
                level: 1
            },
            SMALL_FISH: {
                name: 'å°é­š',
                emoji: 'ğŸ ',
                size: 8,
                speed: 2,
                value: 10,
                behavior: 'schooling',
                description: 'ç¾¤ã‚Œã§æ³³ãå°ã•ãªé­šã€‚æ „é¤Šä¾¡ãŒé«˜ã„ï¼',
                color: ['#FFD700', '#FF6347', '#32CD32'],
                level: 1
            },
            SHRIMP: {
                name: 'ã‚¨ãƒ“',
                emoji: 'ğŸ¦',
                size: 10,
                speed: 3,
                value: 15,
                behavior: 'jumping',
                description: 'ãƒ”ãƒ§ãƒ³ãƒ”ãƒ§ãƒ³è·³ã­ã‚‹ã‚¨ãƒ“ã€‚ç´ æ—©ã„ï¼',
                color: ['#FF69B4', '#FFA500', '#FF6347'],
                level: 1
            },
            CRAB: {
                name: 'ã‚«ãƒ‹',
                emoji: 'ğŸ¦€',
                size: 12,
                speed: 1,
                value: 20,
                behavior: 'sideways_crawling',
                description: 'æ¨ªæ­©ãã™ã‚‹ã‚«ãƒ‹ã€‚ãƒã‚µãƒŸã§åæ’ƒã—ã¦ãã‚‹ï¼',
                color: ['#FF4500', '#DC143C', '#B22222'],
                level: 2,
                hasClaws: true
            },
            
            // ãƒ¬ãƒ™ãƒ«2-3ï¼šä¸­å‹é­šé¡
            HORSE_MACKEREL: {
                name: 'ã‚¢ã‚¸',
                emoji: 'ğŸŸ',
                size: 15,
                speed: 4,
                value: 25,
                behavior: 'fast_schooling',
                description: 'å¤§ç¾¤ã§ç´ æ—©ãæ³³ãã‚¢ã‚¸ã€‚æ•ã¾ãˆã‚‹ã®ã¯å›°é›£ï¼',
                color: ['#4169E1', '#1E90FF', '#00BFFF'],
                level: 2
            },
            MEDIUM_FISH: {
                name: 'ä¸­é­š',
                emoji: 'ğŸŸ',
                size: 18,
                speed: 2,
                value: 30,
                behavior: 'wandering',
                description: 'ä¸­å‹ã®é­šã€‚ã‚ˆã‚Šå¤šãã®æ „é¤Šã‚’æä¾›ã™ã‚‹ã€‚',
                color: ['#4169E1', '#FF1493', '#00CED1'],
                level: 2
            },
            PUFFERFISH: {
                name: 'ãƒ•ã‚°',
                emoji: 'ğŸ¡',
                size: 16,
                speed: 1.5,
                value: 35,
                behavior: 'puffer_defense',
                description: 'å±é™ºã‚’æ„Ÿã˜ã‚‹ã¨è†¨ã‚‰ã‚“ã§æ¯’é‡ã‚’å‡ºã™ï¼',
                color: ['#FFFF00', '#FFA500', '#FF8C00'],
                level: 3,
                dangerous: true,
                canInflate: true
            },
            SEA_URCHIN: {
                name: 'ã‚¦ãƒ‹',
                emoji: 'ğŸ”µ',
                size: 10,
                speed: 0.2,
                value: -15,
                behavior: 'stationary',
                description: 'ãƒˆã‚²ãƒˆã‚²ã®ã‚¦ãƒ‹ã€‚è§¦ã‚‹ã¨ç—›ã„ï¼',
                color: ['#4B0082', '#800080', '#8B008B'],
                level: 2,
                dangerous: true,
                hasSpines: true
            },
            
            // ãƒ¬ãƒ™ãƒ«3-4ï¼šç‰¹æ®Šç”Ÿç‰©
            OCTOPUS: {
                name: 'ã‚¿ã‚³',
                emoji: 'ğŸ™',
                size: 20,
                speed: 2,
                value: 50,
                behavior: 'tentacle_attack',
                description: 'ã‚¿ã‚³ã¯8æœ¬ã®è¶³ã‚’ä¼¸ã°ã—ã¦æ”»æ’ƒã—ã¦ãã‚‹ï¼',
                color: ['#8B0000', '#FF4500', '#9932CC'],
                level: 3
            },
            SQUID: {
                name: 'ã‚¤ã‚«',
                emoji: 'ğŸ¦‘',
                size: 18,
                speed: 3,
                value: 40,
                behavior: 'ink_defense',
                description: 'å±é™ºã‚’æ„Ÿã˜ã‚‹ã¨å¢¨ã‚’åã„ã¦é€ƒã’ã‚‹ï¼',
                color: ['#2F4F4F', '#8A2BE2', '#DC143C'],
                level: 3
            },
            JELLYFISH: {
                name: 'ã‚¯ãƒ©ã‚²',
                emoji: 'ğŸª¼',
                size: 25,
                speed: 0.8,
                value: -20,
                behavior: 'drifting',
                description: 'ã‚†ã‚‰ã‚†ã‚‰æ¼‚ã†ã‚¯ãƒ©ã‚²ã€‚è§¦ã‚‹ã¨ç—›ã„ï¼',
                color: ['#FFB6C1', '#DA70D6', '#87CEEB'],
                level: 3,
                dangerous: true
            },
            SEA_TURTLE: {
                name: 'ã‚¦ãƒŸã‚¬ãƒ¡',
                emoji: 'ğŸ¢',
                size: 30,
                speed: 1,
                value: 60,
                behavior: 'slow_swimming',
                description: 'ã‚†ã£ãã‚Šæ³³ãã‚¦ãƒŸã‚¬ãƒ¡ã€‚é•·ç”Ÿãã®è±¡å¾´ã€‚',
                color: ['#228B22', '#32CD32', '#006400'],
                level: 4
            },
            
            // ãƒ¬ãƒ™ãƒ«4-5ï¼šå¤§å‹é­šé¡
            TUNA: {
                name: 'ãƒã‚°ãƒ­',
                emoji: 'ğŸŸ',
                size: 35,
                speed: 5,
                value: 80,
                behavior: 'fast_swimming',
                description: 'æµ·ã®å¼¾ä¸¸ï¼éå¸¸ã«é€Ÿãæ³³ããƒã‚°ãƒ­ã€‚',
                color: ['#2F4F4F', '#708090', '#556B2F'],
                level: 4
            },
            MANTA_RAY: {
                name: 'ãƒãƒ³ã‚¿',
                emoji: 'ğŸŸ«',
                size: 45,
                speed: 2,
                value: 100,
                behavior: 'graceful_gliding',
                description: 'å„ªé›…ã«æ³³ãå·¨å¤§ãªãƒãƒ³ã‚¿ã€‚ãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³ã‚’é£Ÿã¹ã‚‹ã€‚',
                color: ['#2F4F4F', '#696969', '#708090'],
                level: 5
            },
            
            // ãƒ¬ãƒ™ãƒ«5-6ï¼šå±é™ºãªæ•é£Ÿè€…
            SHARK: {
                name: 'ã‚µãƒ¡',
                emoji: 'ğŸ¦ˆ',
                size: 40,
                speed: 3.5,
                value: -100,
                behavior: 'apex_predator',
                description: 'æµ·ã®ç‹è€…ï¼é‹­ã„æ­¯ã§ä½•ã§ã‚‚é£Ÿã¹ã‚‹ï¼',
                color: ['#708090', '#2F4F4F', '#696969'],
                level: 5,
                dangerous: true,
                isApexPredator: true
            },
            ELECTRIC_RAY: {
                name: 'ã‚·ãƒ“ãƒ¬ã‚¨ã‚¤',
                emoji: 'âš¡',
                size: 25,
                speed: 1.5,
                value: -30,
                behavior: 'electric_shock',
                description: 'é›»æ°—ã‚·ãƒ§ãƒƒã‚¯ã§æ”»æ’ƒã—ã¦ãã‚‹ï¼',
                color: ['#FFD700', '#FFFF00', '#FFA500'],
                level: 5,
                dangerous: true,
                hasElectricity: true
            },
            
            // ãƒ¬ãƒ™ãƒ«6+ï¼šå·¨å¤§ç”Ÿç‰©
            SMALL_WHALE: {
                name: 'å°å‹ã‚¯ã‚¸ãƒ©',
                emoji: 'ğŸ‹',
                size: 60,
                speed: 2,
                value: 200,
                behavior: 'whale_feeding',
                description: 'ãƒãƒ–ãƒ«ãƒãƒƒãƒˆã§å°é­šã‚’ä¸€ç¶²æ‰“å°½ï¼',
                color: ['#2F4F4F', '#4682B4', '#5F9EA0'],
                level: 6,
                isMammal: true
            },
            WHALE: {
                name: 'ã‚¯ã‚¸ãƒ©',
                emoji: 'ğŸ‹',
                size: 80,
                speed: 1.5,
                value: 500,
                behavior: 'whale_feeding',
                description: 'æµ·ã®å·¨äººï¼å¤§é‡ã®ãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³ã‚’é£²ã¿è¾¼ã‚€ï¼',
                color: ['#191970', '#2F4F4F', '#4682B4'],
                level: 7,
                isMammal: true,
                isGiant: true
            },
            
            // ç‰¹åˆ¥ã‚¢ã‚¤ãƒ†ãƒ 
            TREASURE: {
                name: 'å®ç®±',
                emoji: 'ğŸ’',
                size: 15,
                speed: 0,
                value: 100,
                behavior: 'treasure',
                description: 'æµ·ã®å®ç‰©ï¼å¤§ããªãƒœãƒ¼ãƒŠã‚¹ï¼',
                color: ['#FFD700', '#FF6347', '#32CD32'],
                level: 1
            },
            POWER_UP: {
                name: 'ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—',
                emoji: 'â­',
                size: 12,
                speed: 0.5,
                value: 50,
                behavior: 'power_up',
                description: 'ä¸€æ™‚çš„ã«ç„¡æ•µã«ãªã‚Œã‚‹ï¼',
                color: ['#FFD700', '#FFFF00', '#FFA500'],
                level: 3,
                isPowerUp: true
            }
        };

        // DOMè¦ç´ ã®å‚ç…§
        const elements = {};

        // DOMè¦ç´ ã‚’å–å¾—
        function getDOMElements() {
            elements.canvas = document.getElementById('gameCanvas');
            elements.ctx = elements.canvas.getContext('2d');
            elements.scoreValue = document.getElementById('scoreValue');
            elements.levelValue = document.getElementById('levelValue');
            elements.startScreen = document.getElementById('startScreen');
            elements.gameOverScreen = document.getElementById('gameOverScreen');
            elements.finalScore = document.getElementById('finalScore');
            elements.startButton = document.getElementById('startButton');
            elements.restartButton = document.getElementById('restartButton');
            elements.tutorial = document.getElementById('tutorial');
            elements.playerInfo = document.getElementById('playerInfo');
            elements.oxygenFill = document.getElementById('oxygenFill');
            elements.healthFill = document.getElementById('healthFill');
            elements.invincibilityStatus = document.getElementById('invincibilityStatus');
            elements.creatureInfo = document.getElementById('creatureInfo');
            elements.achievements = document.getElementById('achievements');
            elements.joystick = document.getElementById('joystick');
            elements.joystickKnob = document.getElementById('joystickKnob');
        }

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
        function resizeCanvas() {
            elements.canvas.width = window.innerWidth;
            elements.canvas.height = window.innerHeight;
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        function setupEventListeners() {
            elements.startButton.addEventListener('click', startGame);
            elements.restartButton.addEventListener('click', startGame);
            
            elements.canvas.addEventListener('click', handleTap);
            elements.canvas.addEventListener('touchstart', handleTap, { passive: false });
            elements.canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            elements.canvas.addEventListener('mousemove', handleMouseMove);
            
            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            setupJoystickEvents();
            
            window.addEventListener('resize', resizeCanvas);
        }

        // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
        function setupJoystickEvents() {
            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ä¸­å¿ƒä½ç½®ã‚’è¨ˆç®—
            function updateJoystickCenter() {
                const rect = elements.joystick.getBoundingClientRect();
                GameState.joystick.centerX = rect.left + rect.width / 2;
                GameState.joystick.centerY = rect.top + rect.height / 2;
            }

            // åˆæœŸä½ç½®è¨­å®š
            updateJoystickCenter();
            window.addEventListener('resize', updateJoystickCenter);

            // ãƒã‚¦ã‚¹/ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
            function handleJoystickStart(e) {
                e.preventDefault();
                GameState.joystick.active = true;
                elements.joystickKnob.classList.add('active');
                updateJoystickPosition(e);
            }

            function handleJoystickMove(e) {
                if (!GameState.joystick.active) return;
                e.preventDefault();
                updateJoystickPosition(e);
            }

            function handleJoystickEnd(e) {
                e.preventDefault();
                GameState.joystick.active = false;
                elements.joystickKnob.classList.remove('active');
                
                // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚’ä¸­å¤®ã«æˆ»ã™
                GameState.joystick.knobX = 0;
                GameState.joystick.knobY = 0;
                GameState.joystick.inputX = 0;
                GameState.joystick.inputY = 0;
                
                elements.joystickKnob.style.left = '50%';
                elements.joystickKnob.style.top = '50%';
            }

            function updateJoystickPosition(e) {
                updateJoystickCenter();
                
                let clientX, clientY;
                if (e.touches && e.touches[0]) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                const deltaX = clientX - GameState.joystick.centerX;
                const deltaY = clientY - GameState.joystick.centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                if (distance <= GameState.joystick.maxDistance) {
                    GameState.joystick.knobX = deltaX;
                    GameState.joystick.knobY = deltaY;
                } else {
                    GameState.joystick.knobX = (deltaX / distance) * GameState.joystick.maxDistance;
                    GameState.joystick.knobY = (deltaY / distance) * GameState.joystick.maxDistance;
                }

                // å…¥åŠ›å€¤ã‚’-1ã‹ã‚‰1ã®ç¯„å›²ã«æ­£è¦åŒ–
                GameState.joystick.inputX = GameState.joystick.knobX / GameState.joystick.maxDistance;
                GameState.joystick.inputY = GameState.joystick.knobY / GameState.joystick.maxDistance;

                // ãƒãƒ–ã®è¡¨ç¤ºä½ç½®ã‚’æ›´æ–°
                const knobLeft = 50 + (GameState.joystick.knobX / GameState.joystick.maxDistance) * 33.33;
                const knobTop = 50 + (GameState.joystick.knobY / GameState.joystick.maxDistance) * 33.33;
                
                elements.joystickKnob.style.left = knobLeft + '%';
                elements.joystickKnob.style.top = knobTop + '%';
            }

            // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
            elements.joystick.addEventListener('mousedown', handleJoystickStart);
            document.addEventListener('mousemove', handleJoystickMove);
            document.addEventListener('mouseup', handleJoystickEnd);

            // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
            elements.joystick.addEventListener('touchstart', handleJoystickStart, { passive: false });
            document.addEventListener('touchmove', handleJoystickMove, { passive: false });
            document.addEventListener('touchend', handleJoystickEnd, { passive: false });
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        function startGame() {
            GameState.score = 0;
            GameState.level = 1;
            GameState.entities = [];
            GameState.particles = [];
            GameState.bubbles = [];
            GameState.gameRunning = true;
            GameState.oxygen = 100;
            GameState.timeOfDay = 0;
            GameState.currentWave = 0;
            GameState.waveIntensity = 0;
            GameState.specialEvents = [];
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆæœŸåŒ–
            GameState.player = {
                x: elements.canvas.width / 2,
                y: elements.canvas.height / 2,
                radius: 15,
                targetX: elements.canvas.width / 2,
                targetY: elements.canvas.height / 2,
                speed: 3,
                type: 'SMALL_FISH',
                color: '#FFD700',
                health: 100,
                specialAbility: null,
                evolutionPoints: 0,
                angle: 0, // é­šã®å‘ã
                targetAngle: 0, // ç›®æ¨™ã®å‘ã
                lastMoveX: 0,
                lastMoveY: 0
            };
            
            // UIæ›´æ–°
            updateUI();
            elements.startScreen.style.display = 'none';
            elements.gameOverScreen.style.display = 'none';
            elements.joystick.style.display = 'block'; // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯è¡¨ç¤º
            
            // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«è¡¨ç¤º
            showTutorial();
            
            // åˆæœŸã®æ³¡ã‚’ç”Ÿæˆ
            for (let i = 0; i < 20; i++) {
                createBubble();
            }
            
            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—é–‹å§‹
            if (GameState.animationId) {
                cancelAnimationFrame(GameState.animationId);
            }
            GameState.lastFrameTime = performance.now();
            gameLoop();
        }

        // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«è¡¨ç¤º
        function showTutorial() {
            elements.tutorial.style.display = 'block';
            setTimeout(() => {
                elements.tutorial.style.display = 'none';
            }, 4000);
        }

        // ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop(currentTime) {
            if (!GameState.gameRunning) return;
            
            // åˆå›å®Ÿè¡Œæ™‚ã®å‡¦ç†
            if (!GameState.lastFrameTime) {
                GameState.lastFrameTime = currentTime;
            }
            
            const deltaTime = Math.min(currentTime - GameState.lastFrameTime, 50); // æœ€å¤§50msã«åˆ¶é™
            GameState.lastFrameTime = currentTime;
            
            update(deltaTime);
            render();
            
            GameState.animationId = requestAnimationFrame(gameLoop);
        }

        // ã‚²ãƒ¼ãƒ æ›´æ–°
        function update(deltaTime) {
            updatePlayer(deltaTime);
            updateEntities(deltaTime);
            updateParticles(deltaTime);
            updateBubbles(deltaTime);
            updateEatingAnimations(deltaTime);
            updateBloodEffects(deltaTime);
            updateInvincibility(deltaTime);
            spawnEntities();
            checkCollisions();
            updateEnvironment(deltaTime);
            updateOxygen(deltaTime);
            checkLevelUp();
        }

        // é£Ÿã¹ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
        function updateEatingAnimations(deltaTime) {
            GameState.eatingAnimations = GameState.eatingAnimations.filter(anim => {
                anim.life -= deltaTime;
                anim.progress = 1 - (anim.life / anim.maxLife);
                return anim.life > 0;
            });
        }

        // è¡€ã—ã¶ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
        function updateBloodEffects(deltaTime) {
            GameState.bloodEffects = GameState.bloodEffects.filter(blood => {
                blood.x += blood.vx;
                blood.y += blood.vy;
                blood.vx *= 0.95; // æŠµæŠ—
                blood.vy *= 0.95;
                blood.vy += 0.1; // é‡åŠ›
                blood.life -= deltaTime;
                blood.alpha = blood.life / blood.maxLife;
                return blood.life > 0;
            });
        }

        // ç„¡æ•µæ™‚é–“æ›´æ–°
        function updateInvincibility(deltaTime) {
            if (GameState.isInvincible) {
                GameState.invincibilityTime -= deltaTime;
                if (GameState.invincibilityTime <= 0) {
                    GameState.isInvincible = false;
                }
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°
        function updatePlayer(deltaTime) {
            const player = GameState.player;
            let moveX = 0, moveY = 0;
            let isMoving = false;
            
            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ã«ã‚ˆã‚‹ç§»å‹•
            if (GameState.joystick.active && (Math.abs(GameState.joystick.inputX) > 0.1 || Math.abs(GameState.joystick.inputY) > 0.1)) {
                // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã«ã‚ˆã‚‹ç›´æ¥åˆ¶å¾¡
                const moveSpeed = player.speed * 1.5;
                moveX = GameState.joystick.inputX * moveSpeed;
                moveY = GameState.joystick.inputY * moveSpeed;
                player.x += moveX;
                player.y += moveY;
                isMoving = true;
            } else {
                // ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ã«ã‚ˆã‚‹ç›®æ¨™ä½ç½®ã¸ã®ç§»å‹•
                const dx = player.targetX - player.x;
                const dy = player.targetY - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 2) {
                    moveX = (dx / distance) * player.speed;
                    moveY = (dy / distance) * player.speed;
                    player.x += moveX;
                    player.y += moveY;
                    isMoving = true;
                }
            }
            
            // ç§»å‹•æ–¹å‘ã«åŸºã¥ã„ã¦è§’åº¦ã‚’è¨ˆç®—
            if (isMoving && (Math.abs(moveX) > 0.1 || Math.abs(moveY) > 0.1)) {
                player.targetAngle = Math.atan2(moveY, moveX);
                player.lastMoveX = moveX;
                player.lastMoveY = moveY;
            }
            
            // è§’åº¦ã‚’æ»‘ã‚‰ã‹ã«è£œé–“
            updatePlayerRotation(player);
            
            // ç”»é¢å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            player.x = Math.max(player.radius, Math.min(elements.canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(elements.canvas.height - player.radius, player.y));
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢ã‚’æ»‘ã‚‰ã‹ã«æ›´æ–°
        function updatePlayerRotation(player) {
            // è§’åº¦ã®å·®ã‚’è¨ˆç®—ï¼ˆ-Ï€ ã‹ã‚‰ Ï€ ã®ç¯„å›²ã«æ­£è¦åŒ–ï¼‰
            let angleDiff = player.targetAngle - player.angle;
            
            // è§’åº¦ã®å·®ã‚’ -Ï€ ã‹ã‚‰ Ï€ ã®ç¯„å›²ã«èª¿æ•´ï¼ˆæœ€çŸ­å›è»¢ã‚’é¸æŠï¼‰
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            
            // æ»‘ã‚‰ã‹ã«å›è»¢ï¼ˆè£œé–“ä¿‚æ•°ã‚’èª¿æ•´ã—ã¦å›è»¢é€Ÿåº¦ã‚’åˆ¶å¾¡ï¼‰
            const rotationSpeed = 0.15;
            player.angle += angleDiff * rotationSpeed;
            
            // è§’åº¦ã‚’ -Ï€ ã‹ã‚‰ Ï€ ã®ç¯„å›²ã«æ­£è¦åŒ–
            while (player.angle > Math.PI) player.angle -= 2 * Math.PI;
            while (player.angle < -Math.PI) player.angle += 2 * Math.PI;
        }

        // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£æ›´æ–°
        function updateEntities(deltaTime) {
            GameState.entities = GameState.entities.filter(entity => {
                updateEntityBehavior(entity, deltaTime);
                
                // ç”»é¢å¤–ã«å‡ºãŸã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’å‰Šé™¤
                return entity.x > -50 && entity.x < elements.canvas.width + 50 &&
                       entity.y > -50 && entity.y < elements.canvas.height + 50;
            });
        }

        // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®è¡Œå‹•æ›´æ–°
        function updateEntityBehavior(entity, deltaTime) {
            const behavior = CreatureTypes[entity.type].behavior;
            
            // å‰ã®é€Ÿåº¦ã‚’ä¿å­˜
            const prevVx = entity.vx;
            const prevVy = entity.vy;
            
            switch (behavior) {
                case 'schooling':
                    updateSchoolingBehavior(entity);
                    break;
                case 'fast_schooling':
                    updateFastSchoolingBehavior(entity);
                    break;
                case 'wandering':
                    updateWanderingBehavior(entity);
                    break;
                case 'tentacle_attack':
                    updateTentacleAttack(entity);
                    break;
                case 'ink_defense':
                    updateInkDefense(entity);
                    break;
                case 'drifting':
                    updateDriftingBehavior(entity);
                    break;
                case 'jumping':
                    updateJumpingBehavior(entity);
                    break;
                case 'slow_crawling':
                    updateSlowCrawling(entity);
                    break;
                case 'predator':
                    updatePredatorBehavior(entity);
                    break;
                case 'apex_predator':
                    updateApexPredatorBehavior(entity);
                    break;
                case 'puffer_defense':
                    updatePufferDefense(entity);
                    break;
                case 'sideways_crawling':
                    updateSidewaysCrawling(entity);
                    break;
                case 'fast_swimming':
                    updateFastSwimming(entity);
                    break;
                case 'graceful_gliding':
                    updateGracefulGliding(entity);
                    break;
                case 'whale_feeding':
                    updateWhaleFeeding(entity);
                    break;
                case 'electric_shock':
                    updateElectricShock(entity);
                    break;
                case 'slow_swimming':
                    updateSlowSwimming(entity);
                    break;
                case 'stationary':
                    updateStationary(entity);
                    break;
                case 'power_up':
                    updatePowerUp(entity);
                    break;
            }
            
            // åŸºæœ¬ç§»å‹•
            entity.x += entity.vx;
            entity.y += entity.vy;
            
            // ç§»å‹•æ–¹å‘ã«åŸºã¥ã„ã¦è§’åº¦ã‚’æ›´æ–°ï¼ˆååˆ†ãªç§»å‹•ãŒã‚ã‚‹å ´åˆã®ã¿ï¼‰
            if (Math.abs(entity.vx) > 0.1 || Math.abs(entity.vy) > 0.1) {
                const targetAngle = Math.atan2(entity.vy, entity.vx);
                
                // æ»‘ã‚‰ã‹ã«è§’åº¦ã‚’è£œé–“
                let angleDiff = targetAngle - entity.angle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                entity.angle += angleDiff * 0.1; // è£œé–“ä¿‚æ•°
                
                // è§’åº¦ã‚’æ­£è¦åŒ–
                while (entity.angle > Math.PI) entity.angle -= 2 * Math.PI;
                while (entity.angle < -Math.PI) entity.angle += 2 * Math.PI;
            }
        }

        // ç¾¤ã‚Œè¡Œå‹•
        function updateSchoolingBehavior(entity) {
            // ä»–ã®å°é­šã¨ã®è·é›¢ã‚’ä¿ã¤
            let avgX = 0, avgY = 0, count = 0;
            GameState.entities.forEach(other => {
                if (other.type === entity.type && other !== entity) {
                    const dx = other.x - entity.x;
                    const dy = other.y - entity.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 50) {
                        avgX += other.x;
                        avgY += other.y;
                        count++;
                    }
                }
            });
            
            if (count > 0) {
                avgX /= count;
                avgY /= count;
                entity.vx += (avgX - entity.x) * 0.001;
                entity.vy += (avgY - entity.y) * 0.001;
            }
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰é€ƒã’ã‚‹
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) {
                entity.vx -= dx * 0.01;
                entity.vy -= dy * 0.01;
            }
        }

        // æ”¾æµªè¡Œå‹•
        function updateWanderingBehavior(entity) {
            if (!entity.targetX || Math.abs(entity.x - entity.targetX) < 20) {
                entity.targetX = Math.random() * elements.canvas.width;
                entity.targetY = Math.random() * elements.canvas.height;
            }
            
            const dx = entity.targetX - entity.x;
            const dy = entity.targetY - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                entity.vx = (dx / dist) * entity.speed * 0.5;
                entity.vy = (dy / dist) * entity.speed * 0.5;
            }
        }

        // ã‚¿ã‚³ã®è§¦æ‰‹æ”»æ’ƒ
        function updateTentacleAttack(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 100) {
                if (!entity.attacking) {
                    entity.attacking = true;
                    entity.attackTime = 0;
                    entity.tentacles = [];
                    
                    // 8æœ¬ã®è§¦æ‰‹ã‚’ä½œæˆ
                    for (let i = 0; i < 8; i++) {
                        entity.tentacles.push({
                            angle: (i / 8) * Math.PI * 2,
                            length: 0,
                            targetLength: 60,
                            extending: true
                        });
                    }
                }
                
                entity.attackTime += 0.05;
                entity.tentacles.forEach(tentacle => {
                    if (tentacle.extending) {
                        tentacle.length = Math.min(tentacle.targetLength, tentacle.length + 2);
                        if (tentacle.length >= tentacle.targetLength) {
                            tentacle.extending = false;
                        }
                    } else {
                        tentacle.length = Math.max(0, tentacle.length - 3);
                    }
                });
                
                if (entity.attackTime > 2) {
                    entity.attacking = false;
                }
            } else {
                entity.attacking = false;
                updateWanderingBehavior(entity);
            }
        }

        // ã‚¤ã‚«ã®å¢¨é˜²å¾¡
        function updateInkDefense(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 60 && !entity.inkCooldown) {
                // å¢¨ã‚’åã
                createInkCloud(entity.x, entity.y);
                entity.inkCooldown = 3000; // 3ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                
                // ç´ æ—©ãé€ƒã’ã‚‹
                entity.vx = -(dx / dist) * 4;
                entity.vy = -(dy / dist) * 4;
            }
            
            if (entity.inkCooldown) {
                entity.inkCooldown -= 16;
                if (entity.inkCooldown <= 0) {
                    entity.inkCooldown = 0;
                }
            } else {
                updateWanderingBehavior(entity);
            }
        }

        // ã‚¯ãƒ©ã‚²ã®æ¼‚æµ
        function updateDriftingBehavior(entity) {
            entity.vx = Math.sin(Date.now() * 0.001 + entity.phase) * 0.5;
            entity.vy = Math.cos(Date.now() * 0.0008 + entity.phase) * 0.3 + 0.2;
            
            // ã‚†ã‚‰ã‚†ã‚‰åŠ¹æœ
            entity.sway = Math.sin(Date.now() * 0.003 + entity.phase) * 10;
        }

        // ã‚¨ãƒ“ã®ã‚¸ãƒ£ãƒ³ãƒ—
        function updateJumpingBehavior(entity) {
            if (!entity.jumpCooldown) {
                entity.jumpCooldown = Math.random() * 100 + 50;
                entity.vx = (Math.random() - 0.5) * 6;
                entity.vy = -Math.random() * 3 - 2;
            }
            
            entity.jumpCooldown--;
            entity.vy += 0.1; // é‡åŠ›
            
            if (entity.y > elements.canvas.height - 50) {
                entity.vy = -Math.abs(entity.vy) * 0.7;
            }
        }

        // ãƒ’ãƒˆãƒ‡ã®ã‚†ã£ãã‚Šç§»å‹•
        function updateSlowCrawling(entity) {
            if (!entity.moveTarget || Math.random() < 0.005) {
                entity.moveTarget = {
                    x: entity.x + (Math.random() - 0.5) * 100,
                    y: entity.y + (Math.random() - 0.5) * 100
                };
            }
            
            const dx = entity.moveTarget.x - entity.x;
            const dy = entity.moveTarget.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 5) {
                entity.vx = (dx / dist) * 0.3;
                entity.vy = (dy / dist) * 0.3;
            }
        }

        // ã‚µãƒ¡ã®æ•é£Ÿè¡Œå‹•
        function updatePredatorBehavior(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 150) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½è·¡
                entity.vx = (dx / dist) * entity.speed;
                entity.vy = (dy / dist) * entity.speed;
            } else {
                updateWanderingBehavior(entity);
            }
        }

        // é ‚ç‚¹æ•é£Ÿè€…ï¼ˆå¤§å‹ã‚µãƒ¡ï¼‰ã®è¡Œå‹•
        function updateApexPredatorBehavior(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 200) {
                // ã‚ˆã‚Šé•·è·é›¢ã‹ã‚‰è¿½è·¡é–‹å§‹
                const speed = entity.speed * 1.2;
                entity.vx = (dx / dist) * speed;
                entity.vy = (dy / dist) * speed;
                
                // æ”»æ’ƒæ…‹å‹¢
                entity.isAttacking = true;
            } else {
                entity.isAttacking = false;
                updateWanderingBehavior(entity);
            }
        }

        // ãƒ•ã‚°ã®é˜²å¾¡è¡Œå‹•
        function updatePufferDefense(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 80 && !entity.isInflated) {
                // è†¨ã‚‰ã‚€
                entity.isInflated = true;
                entity.inflationTime = Date.now();
                entity.originalRadius = entity.radius;
                entity.targetRadius = entity.radius * 2;
                entity.hasSpines = true;
                
                // æ¯’ã®æ³¡ã‚’æ”¾å‡º
                createPoisonBubbles(entity.x, entity.y);
            }
            
            if (entity.isInflated) {
                // è†¨ã‚‰ã‚“ã çŠ¶æ…‹ã®å‡¦ç†
                const elapsed = Date.now() - entity.inflationTime;
                const progress = Math.min(elapsed / 1000, 1);
                entity.radius = entity.originalRadius + (entity.targetRadius - entity.originalRadius) * progress;
                
                // 3ç§’å¾Œã«å…ƒã«æˆ»ã‚‹
                if (elapsed > 3000) {
                    entity.isInflated = false;
                    entity.radius = entity.originalRadius;
                    entity.hasSpines = false;
                }
                
                // è†¨ã‚‰ã‚“ã§ã„ã‚‹é–“ã¯ã‚†ã£ãã‚Šå‹•ã
                entity.vx *= 0.5;
                entity.vy *= 0.5;
            } else {
                updateWanderingBehavior(entity);
            }
        }

        // ã‚¢ã‚¸ã®é«˜é€Ÿç¾¤ã‚Œè¡Œå‹•
        function updateFastSchoolingBehavior(entity) {
            // åŸºæœ¬ã®ç¾¤ã‚Œè¡Œå‹•
            updateSchoolingBehavior(entity);
            
            // ã‚ˆã‚Šé«˜é€Ÿã§çµ±ç‡ã•ã‚ŒãŸå‹•ã
            entity.vx *= 1.5;
            entity.vy *= 1.5;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ç´ æ—©ãé€ƒã’ã‚‹
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 100) {
                entity.vx -= (dx / dist) * 2;
                entity.vy -= (dy / dist) * 2;
            }
        }

        // ã‚«ãƒ‹ã®æ¨ªæ­©ã
        function updateSidewaysCrawling(entity) {
            if (!entity.sidewaysDirection) {
                entity.sidewaysDirection = Math.random() < 0.5 ? 1 : -1;
                entity.moveTime = 0;
            }
            
            entity.moveTime += 0.02;
            
            // æ¨ªå‘ãã®å‹•ã
            entity.vx = entity.sidewaysDirection * entity.speed;
            entity.vy = Math.sin(entity.moveTime) * 0.2;
            
            // æ–¹å‘è»¢æ›
            if (Math.random() < 0.005) {
                entity.sidewaysDirection *= -1;
            }
            
            // ãƒã‚µãƒŸæ”»æ’ƒ
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 40) {
                entity.isAttacking = true;
                entity.attackTime = Date.now();
            }
        }

        // é«˜é€ŸéŠæ³³ï¼ˆãƒã‚°ãƒ­ï¼‰
        function updateFastSwimming(entity) {
            if (!entity.targetX || Math.abs(entity.x - entity.targetX) < 50) {
                entity.targetX = Math.random() * elements.canvas.width;
                entity.targetY = Math.random() * elements.canvas.height;
            }
            
            const dx = entity.targetX - entity.x;
            const dy = entity.targetY - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                entity.vx = (dx / dist) * entity.speed;
                entity.vy = (dy / dist) * entity.speed;
            }
        }

        // å„ªé›…ãªæ»‘ç©ºï¼ˆãƒãƒ³ã‚¿ï¼‰
        function updateGracefulGliding(entity) {
            entity.glideTime = (entity.glideTime || 0) + 0.02;
            
            entity.vx = Math.sin(entity.glideTime * 0.5) * entity.speed;
            entity.vy = Math.cos(entity.glideTime * 0.3) * entity.speed * 0.5;
            
            // ãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³ã‚’æ¢ã™
            GameState.entities.forEach(other => {
                if (other.type === 'PLANKTON') {
                    const dx = other.x - entity.x;
                    const dy = other.y - entity.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 60) {
                        entity.vx += (dx / dist) * 0.5;
                        entity.vy += (dy / dist) * 0.5;
                    }
                }
            });
        }

        // ã‚¯ã‚¸ãƒ©ã®æ•é£Ÿè¡Œå‹•
        function updateWhaleFeeding(entity) {
            if (!entity.feedingCooldown) {
                entity.feedingCooldown = 0;
            }
            
            entity.feedingCooldown--;
            
            // ãƒãƒ–ãƒ«ãƒãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
            if (entity.feedingCooldown <= 0) {
                const nearbySmallFish = GameState.entities.filter(other => 
                    ['SMALL_FISH', 'PLANKTON', 'SHRIMP'].includes(other.type)
                );
                
                if (nearbySmallFish.length > 3) {
                    entity.feedingCooldown = 300; // 5ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                    entity.isFeeding = true;
                    entity.feedingTime = Date.now();
                    
                    // ãƒãƒ–ãƒ«ã‚’ä½œæˆ
                    createBubbleNet(entity.x, entity.y);
                }
            }
            
            if (entity.isFeeding) {
                const elapsed = Date.now() - entity.feedingTime;
                if (elapsed > 2000) {
                    entity.isFeeding = false;
                }
                
                // å¸ã„è¾¼ã¿åŠ¹æœ
                GameState.entities.forEach(other => {
                    if (['SMALL_FISH', 'PLANKTON', 'SHRIMP'].includes(other.type)) {
                        const dx = entity.x - other.x;
                        const dy = entity.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            other.vx += (dx / dist) * 2;
                            other.vy += (dy / dist) * 2;
                        }
                    }
                });
            } else {
                updateWanderingBehavior(entity);
            }
        }

        // é›»æ°—ã‚·ãƒ§ãƒƒã‚¯ï¼ˆã‚·ãƒ“ãƒ¬ã‚¨ã‚¤ï¼‰
        function updateElectricShock(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 60 && !entity.shockCooldown) {
                entity.shockCooldown = 180; // 3ç§’
                entity.isCharging = true;
                entity.chargeTime = Date.now();
                
                // é›»æ°—ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                createElectricEffect(entity.x, entity.y);
            }
            
            if (entity.shockCooldown) {
                entity.shockCooldown--;
            }
            
            if (entity.isCharging) {
                const elapsed = Date.now() - entity.chargeTime;
                if (elapsed > 1000) {
                    entity.isCharging = false;
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç¯„å›²å†…ã«ã„ã‚Œã°ãƒ€ãƒ¡ãƒ¼ã‚¸
                    if (dist < 80) {
                        GameState.player.health -= 30;
                        createParticleEffect(GameState.player.x, GameState.player.y, '#FFFF00');
                    }
                }
            } else {
                updateWanderingBehavior(entity);
            }
        }

        // ã‚†ã£ãã‚Šæ³³ãï¼ˆã‚¦ãƒŸã‚¬ãƒ¡ï¼‰
        function updateSlowSwimming(entity) {
            updateWanderingBehavior(entity);
            entity.vx *= 0.3;
            entity.vy *= 0.3;
        }

        // å›ºå®šï¼ˆã‚¦ãƒ‹ï¼‰
        function updateStationary(entity) {
            entity.vx = 0;
            entity.vy = 0;
            
            // ã‚ãšã‹ã«æºã‚Œã‚‹
            entity.y += Math.sin(Date.now() * 0.002 + entity.phase) * 0.1;
        }

        // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 
        function updatePowerUp(entity) {
            entity.glowTime = (entity.glowTime || 0) + 0.1;
            entity.glowIntensity = Math.sin(entity.glowTime) * 0.5 + 0.5;
            
            updateDriftingBehavior(entity);
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
        function updateParticles(deltaTime) {
            GameState.particles = GameState.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= deltaTime;
                particle.alpha = particle.life / particle.maxLife;
                return particle.life > 0;
            });
        }

        // æ³¡æ›´æ–°
        function updateBubbles(deltaTime) {
            GameState.bubbles.forEach(bubble => {
                bubble.y -= bubble.speed;
                bubble.x += Math.sin(bubble.y * 0.01) * 0.5;
                
                if (bubble.y < -20) {
                    bubble.y = elements.canvas.height + 20;
                    bubble.x = Math.random() * elements.canvas.width;
                }
            });
        }

        // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ç”Ÿæˆ
        function spawnEntities() {
            const now = Date.now();
            if (now - GameState.lastSpawnTime > 1500 - (GameState.level * 80)) {
                GameState.lastSpawnTime = now;
                
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸç”Ÿç‰©ã‚’é¸æŠ
                const availableTypes = Object.keys(CreatureTypes).filter(type => {
                    const creature = CreatureTypes[type];
                    if (!creature.level) return true; // ãƒ¬ãƒ™ãƒ«æŒ‡å®šãªã—ã¯å¸¸ã«å‡ºç¾
                    
                    // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸå‡ºç¾ç¢ºç‡
                    if (creature.level <= GameState.level) {
                        if (creature.level === GameState.level) return Math.random() < 0.7;
                        if (creature.level === GameState.level - 1) return Math.random() < 0.8;
                        if (creature.level < GameState.level - 1) return Math.random() < 0.4;
                        return true;
                    }
                    
                    // ä¸Šä½ãƒ¬ãƒ™ãƒ«ã®ç”Ÿç‰©ã‚‚ä½ç¢ºç‡ã§å‡ºç¾
                    if (creature.level === GameState.level + 1) return Math.random() < 0.2;
                    if (creature.level === GameState.level + 2) return Math.random() < 0.05;
                    
                    return false;
                });
                
                // ç‰¹åˆ¥ãªã‚¢ã‚¤ãƒ†ãƒ ã®å‡ºç¾ç¢ºç‡èª¿æ•´
                const filteredTypes = availableTypes.filter(type => {
                    if (type === 'TREASURE') return Math.random() < 0.08;
                    if (type === 'POWER_UP') return Math.random() < 0.05;
                    return true;
                });
                
                if (filteredTypes.length > 0) {
                    const randomType = filteredTypes[Math.floor(Math.random() * filteredTypes.length)];
                    createEntity(randomType);
                }
            }
        }

        // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ä½œæˆ
        function createEntity(type) {
            const creatureType = CreatureTypes[type];
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch (side) {
                case 0: // ä¸Š
                    x = Math.random() * elements.canvas.width;
                    y = -50;
                    break;
                case 1: // å³
                    x = elements.canvas.width + 50;
                    y = Math.random() * elements.canvas.height;
                    break;
                case 2: // ä¸‹
                    x = Math.random() * elements.canvas.width;
                    y = elements.canvas.height + 50;
                    break;
                case 3: // å·¦
                    x = -50;
                    y = Math.random() * elements.canvas.height;
                    break;
            }
            
            const entity = {
                x: x,
                y: y,
                type: type,
                radius: creatureType.size,
                speed: creatureType.speed,
                vx: (Math.random() - 0.5) * creatureType.speed,
                vy: (Math.random() - 0.5) * creatureType.speed,
                color: creatureType.color[Math.floor(Math.random() * creatureType.color.length)],
                phase: Math.random() * Math.PI * 2,
                health: creatureType.size * 2,
                angle: Math.atan2((Math.random() - 0.5) * creatureType.speed, (Math.random() - 0.5) * creatureType.speed),
                lastVx: 0,
                lastVy: 0
            };
            
            GameState.entities.push(entity);
        }

        // è¡çªæ¤œå‡º
        function checkCollisions() {
            const player = GameState.player;
            
            for (let i = GameState.entities.length - 1; i >= 0; i--) {
                const entity = GameState.entities[i];
                const dx = player.x - entity.x;
                const dy = player.y - entity.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.radius + entity.radius) {
                    handleCollision(entity, i);
                    updateUI(); // UIæ›´æ–°
                    break; // ä¸€åº¦ã«ä¸€ã¤ã®è¡çªã®ã¿å‡¦ç†
                }
            }
        }

        // è¡çªå‡¦ç†
        function handleCollision(entity, index) {
            const creatureType = CreatureTypes[entity.type];
            const player = GameState.player;
            
            // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 
            if (creatureType.isPowerUp) {
                GameState.score += creatureType.value;
                GameState.isInvincible = true;
                GameState.invincibilityTime = 5000; // 5ç§’é–“ç„¡æ•µ
                createParticleEffect(entity.x, entity.y, '#FFD700');
                GameState.entities.splice(index, 1);
                return;
            }
            
            // ç„¡æ•µæ™‚é–“ä¸­ã¯å±é™ºãªç”Ÿç‰©ã«è§¦ã‚Œã¦ã‚‚ãƒ€ãƒ¡ãƒ¼ã‚¸ãªã—
            if (GameState.isInvincible && creatureType.dangerous) {
                return;
            }
            
            // ã‚µã‚¤ã‚ºæ¯”è¼ƒã«ã‚ˆã‚‹é£Ÿç‰©é€£é–
            const canEatPrey = player.radius >= entity.radius * 0.8;
            const canEatPredator = entity.radius >= player.radius * 0.8;
            
            if (creatureType.dangerous && canEatPredator) {
                // å±é™ºãªç”Ÿç‰©ã«é£Ÿã¹ã‚‰ã‚Œã‚‹
                handlePlayerEaten(entity);
            } else if (!creatureType.dangerous && canEatPrey) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç”Ÿç‰©ã‚’é£Ÿã¹ã‚‹
                handlePreyEaten(entity, index);
            } else if (creatureType.dangerous) {
                // å±é™ºãªç”Ÿç‰©ã¨ã®æ¥è§¦ï¼ˆé£Ÿã¹ã‚‰ã‚Œãªã„ãŒã€ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
                handleDangerousContact(entity);
            } else {
                // é£Ÿã¹ã‚‰ã‚Œãªã„ç”Ÿç‰©ã¨ã®è»½ã„æ¥è§¦
                handleNeutralContact(entity);
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé£Ÿã¹ã‚‰ã‚Œã‚‹å‡¦ç†
        function handlePlayerEaten(predator) {
            const creatureType = CreatureTypes[predator.type];
            
            // é£Ÿã¹ã‚‰ã‚Œã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            createEatingAnimation(predator.x, predator.y, GameState.player.x, GameState.player.y, GameState.player.radius);
            
            // è¡€ã—ã¶ã
            createBloodEffect(GameState.player.x, GameState.player.y, 2);
            
            // ç‰¹åˆ¥ãªåŠ¹æœ
            if (creatureType.isApexPredator) {
                // ã‚µãƒ¡ãªã©ã®é ‚ç‚¹æ•é£Ÿè€…
                createParticleEffect(predator.x, predator.y, '#FF0000');
                gameOver();
            } else {
                // é€šå¸¸ã®å±é™ºç”Ÿç‰©
                GameState.player.health -= 40;
                GameState.isInvincible = true;
                GameState.invincibilityTime = 2000;
                
                if (GameState.player.health <= 0) {
                    gameOver();
                }
            }
        }

        // ç²ç‰©ã‚’é£Ÿã¹ã‚‹å‡¦ç†
        function handlePreyEaten(prey, index) {
            const creatureType = CreatureTypes[prey.type];
            
            // é£Ÿã¹ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            createEatingAnimation(GameState.player.x, GameState.player.y, prey.x, prey.y, prey.radius);
            
            // ã‚¹ã‚³ã‚¢å¢—åŠ 
            GameState.score += creatureType.value;
            GameState.player.evolutionPoints += Math.max(creatureType.value / 10, 1);
            
            // ã‚µã‚¤ã‚ºã«ã‚ˆã‚‹æˆé•·
            if (prey.radius >= GameState.player.radius * 0.5) {
                GameState.player.radius += 0.5;
                createParticleEffect(GameState.player.x, GameState.player.y, '#00FF00');
            }
            
            // ç‰¹åˆ¥ãªåŠ¹æœ
            if (creatureType.isMammal) {
                // å“ºä¹³é¡ã‚’é£Ÿã¹ã‚‹ã¨å¤§ããæˆé•·
                GameState.player.radius += 2;
                GameState.score += 50;
            }
            
            // é€²åŒ–ãƒã‚§ãƒƒã‚¯
            if (GameState.player.evolutionPoints >= 100) {
                evolvePlayer();
            }
            
            // é…¸ç´ å›å¾©
            GameState.oxygen = Math.min(100, GameState.oxygen + 5);
            
            // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å‰Šé™¤
            GameState.entities.splice(index, 1);
        }

        // å±é™ºãªç”Ÿç‰©ã¨ã®æ¥è§¦
        function handleDangerousContact(entity) {
            const creatureType = CreatureTypes[entity.type];
            
            if (creatureType.hasSpines || creatureType.type === 'SEA_URCHIN') {
                // ãƒˆã‚²ã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸
                GameState.player.health -= 15;
                createParticleEffect(entity.x, entity.y, '#8B008B');
            } else if (creatureType.hasElectricity) {
                // é›»æ°—ã‚·ãƒ§ãƒƒã‚¯
                GameState.player.health -= 20;
                createElectricEffect(entity.x, entity.y);
            } else if (creatureType.type === 'JELLYFISH') {
                // ã‚¯ãƒ©ã‚²ã®æ¯’
                GameState.player.health -= 10;
                createParticleEffect(entity.x, entity.y, '#FFB6C1');
            } else {
                // ä¸€èˆ¬çš„ãªå±é™ºç”Ÿç‰©
                GameState.player.health -= 10;
                createParticleEffect(entity.x, entity.y, '#FF4500');
            }
            
            // ç„¡æ•µæ™‚é–“ä»˜ä¸
            GameState.isInvincible = true;
            GameState.invincibilityTime = 1500;
            
            if (GameState.player.health <= 0) {
                gameOver();
            }
        }

        // ä¸­ç«‹çš„ãªæ¥è§¦
        function handleNeutralContact(entity) {
            // è»½ã„ãƒãƒƒã‚¯ãƒãƒƒã‚¯
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                const pushForce = 3;
                GameState.player.x += (dx / distance) * pushForce;
                GameState.player.y += (dy / distance) * pushForce;
                entity.x -= (dx / distance) * pushForce;
                entity.y -= (dy / distance) * pushForce;
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é€²åŒ–
        function evolvePlayer() {
            GameState.player.evolutionPoints = 0;
            GameState.player.radius += 3;
            GameState.player.health = 100;
            
            // é€²åŒ–ã«å¿œã˜ã¦ã‚¿ã‚¤ãƒ—ã‚’å¤‰æ›´
            if (GameState.player.radius > 20 && GameState.player.type === 'SMALL_FISH') {
                GameState.player.type = 'MEDIUM_FISH';
                GameState.player.color = '#4169E1';
            } else if (GameState.player.radius > 30 && GameState.player.type === 'MEDIUM_FISH') {
                GameState.player.type = 'LARGE_FISH';
                GameState.player.color = '#FF6347';
            }
            
            createParticleEffect(GameState.player.x, GameState.player.y, '#FFD700');
        }

        // ç’°å¢ƒæ›´æ–°
        function updateEnvironment(deltaTime) {
            // ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ãŒæœ‰åŠ¹ãªæ•°å€¤ã‹ãƒã‚§ãƒƒã‚¯
            if (!deltaTime || isNaN(deltaTime)) deltaTime = 16;
            
            GameState.timeOfDay += deltaTime * 0.0001;
            if (GameState.timeOfDay > 1) GameState.timeOfDay = 0;
            
            GameState.currentWave += deltaTime * 0.001;
            GameState.waveIntensity = Math.sin(GameState.currentWave) * 5;
        }

        // é…¸ç´ æ›´æ–°
        function updateOxygen(deltaTime) {
            GameState.oxygen -= deltaTime * 0.01;
            if (GameState.oxygen <= 0) {
                gameOver();
            }
        }

        // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯
        function checkLevelUp() {
            const newLevel = Math.floor(GameState.score / 500) + 1;
            if (newLevel > GameState.level) {
                GameState.level = newLevel;
                createSpecialEvent();
            }
        }

        // ç‰¹åˆ¥ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ
        function createSpecialEvent() {
            // å®ç®±ã‚„ç‰¹åˆ¥ãªç”Ÿç‰©ã®å‡ºç¾
            for (let i = 0; i < 3; i++) {
                setTimeout(() => createEntity('TREASURE'), i * 1000);
            }
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœä½œæˆ
        function createParticleEffect(x, y, color) {
            for (let i = 0; i < 10; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: color,
                    life: 1000,
                    maxLife: 1000,
                    alpha: 1
                });
            }
        }

        // å¢¨é›²ä½œæˆ
        function createInkCloud(x, y) {
            for (let i = 0; i < 20; i++) {
                GameState.particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: '#2F4F4F',
                    life: 3000,
                    maxLife: 3000,
                    alpha: 1,
                    size: Math.random() * 10 + 5
                });
            }
        }

        // æ¯’ã®æ³¡ä½œæˆï¼ˆãƒ•ã‚°ç”¨ï¼‰
        function createPoisonBubbles(x, y) {
            for (let i = 0; i < 15; i++) {
                GameState.particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    color: '#90EE90',
                    life: 2000,
                    maxLife: 2000,
                    alpha: 0.8,
                    size: Math.random() * 8 + 3,
                    isPoisonous: true
                });
            }
        }

        // ãƒãƒ–ãƒ«ãƒãƒƒãƒˆä½œæˆï¼ˆã‚¯ã‚¸ãƒ©ç”¨ï¼‰
        function createBubbleNet(x, y) {
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                const radius = Math.random() * 80 + 20;
                GameState.particles.push({
                    x: x + Math.cos(angle) * radius,
                    y: y + Math.sin(angle) * radius,
                    vx: Math.cos(angle) * 0.5,
                    vy: Math.sin(angle) * 0.5 - 1,
                    color: '#87CEEB',
                    life: 3000,
                    maxLife: 3000,
                    alpha: 0.6,
                    size: Math.random() * 6 + 2
                });
            }
        }

        // é›»æ°—ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½œæˆ
        function createElectricEffect(x, y) {
            for (let i = 0; i < 20; i++) {
                GameState.particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: '#FFFF00',
                    life: 500,
                    maxLife: 500,
                    alpha: 1,
                    size: Math.random() * 4 + 1,
                    isElectric: true
                });
            }
        }

        // è¡€ã—ã¶ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆä½œæˆ
        function createBloodEffect(x, y, intensity = 1) {
            for (let i = 0; i < 10 * intensity; i++) {
                GameState.bloodEffects.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 2000,
                    maxLife: 2000,
                    size: Math.random() * 4 + 2,
                    alpha: 1
                });
            }
        }

        // é£Ÿã¹ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
        function createEatingAnimation(predatorX, predatorY, preyX, preyY, preySize) {
            GameState.eatingAnimations.push({
                predatorX: predatorX,
                predatorY: predatorY,
                preyX: preyX,
                preyY: preyY,
                preySize: preySize,
                progress: 0,
                maxProgress: 1,
                life: 800,
                maxLife: 800
            });
        }

        // æ³¡ä½œæˆ
        function createBubble() {
            GameState.bubbles.push({
                x: Math.random() * elements.canvas.width,
                y: elements.canvas.height + 20,
                radius: Math.random() * 5 + 2,
                speed: Math.random() * 2 + 0.5,
                alpha: Math.random() * 0.5 + 0.3
            });
        }

        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
        function render() {
            const ctx = elements.ctx;
            const canvas = elements.canvas;
            
            // èƒŒæ™¯ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // æµ·ã®èƒŒæ™¯ã‚’æç”»
            drawOceanBackground(ctx);
            
            // æ³¢åŠ¹æœ
            ctx.save();
            const waveOffset = GameState.waveIntensity || 0;
            ctx.translate(0, waveOffset);
            
            // æ³¡ã‚’æç”»
            drawBubbles(ctx);
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æç”»
            drawParticles(ctx);
            
            // è¡€ã—ã¶ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æç”»
            drawBloodEffects(ctx);
            
            // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’æç”»
            drawEntities(ctx);
            
            // é£Ÿã¹ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æç”»
            drawEatingAnimations(ctx);
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
            drawPlayer(ctx);
            
            ctx.restore();
            
            // UIåŠ¹æœ
            drawUIEffects(ctx);
        }

        // æµ·ã®èƒŒæ™¯æç”»
        function drawOceanBackground(ctx) {
            // æ™‚é–“ã«åŸºã¥ãè‰²ã®å¤‰åŒ–ï¼ˆå®‰å…¨ãªè¨ˆç®—ï¼‰
            const timeOfDay = GameState.timeOfDay || 0;
            const dayColor = { r: 135, g: 206, b: 250 };
            const nightColor = { r: 25, g: 25, b: 112 };
            
            const blend = Math.max(0, Math.min(1, Math.sin(timeOfDay * Math.PI * 2) * 0.5 + 0.5));
            const currentColor = {
                r: Math.floor(dayColor.r * blend + nightColor.r * (1 - blend)),
                g: Math.floor(dayColor.g * blend + nightColor.g * (1 - blend)),
                b: Math.floor(dayColor.b * blend + nightColor.b * (1 - blend))
            };
            
            // å€¤ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
            if (isNaN(currentColor.r) || isNaN(currentColor.g) || isNaN(currentColor.b)) {
                currentColor.r = 135;
                currentColor.g = 206;
                currentColor.b = 250;
            }
            
            // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, elements.canvas.height);
            gradient.addColorStop(0, `rgba(${currentColor.r}, ${currentColor.g}, ${currentColor.b}, 0.8)`);
            gradient.addColorStop(0.3, `rgba(${Math.floor(currentColor.r * 0.8)}, ${Math.floor(currentColor.g * 0.9)}, ${Math.floor(currentColor.b * 1.2)}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.floor(currentColor.r * 0.3)}, ${Math.floor(currentColor.g * 0.3)}, ${Math.floor(currentColor.b * 0.8)}, 1)`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, elements.canvas.width, elements.canvas.height);
            
            // æµ·è—»ã‚„çŠç‘šã®ç°¡å˜ãªæç”»
            drawSeaweed(ctx);
        }

        // æµ·è—»æç”»
        function drawSeaweed(ctx) {
            ctx.strokeStyle = 'rgba(34, 139, 34, 0.6)';
            ctx.lineWidth = 3;
            
            const currentWave = GameState.currentWave || 0;
            
            for (let i = 0; i < 5; i++) {
                const x = (i / 4) * elements.canvas.width;
                const baseY = elements.canvas.height - 50;
                
                ctx.beginPath();
                ctx.moveTo(x, baseY);
                
                for (let j = 0; j < 100; j += 10) {
                    const waveX = x + Math.sin((baseY - j) * 0.02 + currentWave) * 20;
                    ctx.lineTo(waveX, baseY - j);
                }
                
                ctx.stroke();
            }
        }

        // æ³¡æç”»
        function drawBubbles(ctx) {
            GameState.bubbles.forEach(bubble => {
                ctx.save();
                ctx.globalAlpha = bubble.alpha;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // å…‰ã®åå°„
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(bubble.x - bubble.radius * 0.3, bubble.y - bubble.radius * 0.3, bubble.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»
        function drawParticles(ctx) {
            GameState.particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                const size = particle.size || 3;
                ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // é›»æ°—ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç‰¹åˆ¥ãªæç”»
                if (particle.isElectric) {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }

        // è¡€ã—ã¶ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»
        function drawBloodEffects(ctx) {
            GameState.bloodEffects.forEach(blood => {
                ctx.save();
                ctx.globalAlpha = blood.alpha;
                ctx.fillStyle = '#8B0000';
                ctx.beginPath();
                ctx.arc(blood.x, blood.y, blood.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // é£Ÿã¹ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æç”»
        function drawEatingAnimations(ctx) {
            GameState.eatingAnimations.forEach(anim => {
                ctx.save();
                
                // ç²ç‰©ãŒæ•é£Ÿè€…ã«å¸ã„è¾¼ã¾ã‚Œã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                const lerpX = anim.preyX + (anim.predatorX - anim.preyX) * anim.progress;
                const lerpY = anim.preyY + (anim.predatorY - anim.preyY) * anim.progress;
                const scale = 1 - anim.progress * 0.8;
                
                ctx.globalAlpha = 1 - anim.progress * 0.5;
                ctx.translate(lerpX, lerpY);
                ctx.scale(scale, scale);
                
                // ç²ç‰©ã®æ®‹åƒ
                ctx.fillStyle = '#FF6347';
                ctx.beginPath();
                ctx.arc(0, 0, anim.preySize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£æç”»
        function drawEntities(ctx) {
            GameState.entities.forEach(entity => {
                drawCreature(ctx, entity);
            });
        }

        // ç”Ÿç‰©æç”»
        function drawCreature(ctx, entity) {
            const creatureType = CreatureTypes[entity.type];
            
            ctx.save();
            ctx.translate(entity.x, entity.y);
            
            // ç”Ÿç‰©ã®å‘ãã«å›è»¢
            ctx.rotate(entity.angle);
            
            if (entity.sway) {
                ctx.rotate(entity.sway * 0.01);
            }
            
            // åŸºæœ¬ã®ä½“
            ctx.fillStyle = entity.color;
            ctx.beginPath();
            
            // é­šé¡ã¯æ¥•å††å½¢ã«ã€ãã®ä»–ã¯å††å½¢ã«
            if (['SMALL_FISH', 'MEDIUM_FISH', 'SHARK'].includes(entity.type)) {
                ctx.ellipse(0, 0, entity.radius, entity.radius * 0.7, 0, 0, Math.PI * 2);
            } else {
                ctx.arc(0, 0, entity.radius, 0, Math.PI * 2);
            }
            ctx.fill();
            
            // ç‰¹åˆ¥ãªæç”»
            switch (entity.type) {
                case 'OCTOPUS':
                    drawOctopus(ctx, entity);
                    break;
                case 'SQUID':
                    drawSquid(ctx, entity);
                    break;
                case 'JELLYFISH':
                    drawJellyfish(ctx, entity);
                    break;
                case 'SHARK':
                    drawShark(ctx, entity);
                    break;
                case 'STARFISH':
                    drawStarfish(ctx, entity);
                    break;
                case 'SMALL_FISH':
                case 'MEDIUM_FISH':
                    drawBasicFishRotated(ctx, entity);
                    break;
                default:
                    drawBasicFishRotated(ctx, entity);
            }
            
            // ç›®ã‚’æç”»ï¼ˆå›è»¢å¯¾å¿œï¼‰
            if (entity.type !== 'STARFISH' && entity.type !== 'TREASURE') {
                drawEyesRotated(ctx, entity);
            }
            
            ctx.restore();
        }

        // å›è»¢å¯¾å¿œã®åŸºæœ¬çš„ãªé­šæç”»
        function drawBasicFishRotated(ctx, entity) {
            // å°»å°¾ï¼ˆå¾Œã‚å´ï¼‰
            ctx.fillStyle = entity.color;
            ctx.beginPath();
            ctx.moveTo(-entity.radius, 0);
            ctx.lineTo(-entity.radius * 1.5, -entity.radius * 0.5);
            ctx.lineTo(-entity.radius * 1.2, 0);
            ctx.lineTo(-entity.radius * 1.5, entity.radius * 0.5);
            ctx.closePath();
            ctx.fill();
            
            // ã²ã‚Œï¼ˆä¸‹å´ï¼‰
            ctx.beginPath();
            ctx.ellipse(-entity.radius * 0.2, entity.radius * 0.5, entity.radius * 0.3, entity.radius * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // å›è»¢å¯¾å¿œã®ç›®æç”»
        function drawEyesRotated(ctx, entity) {
            const eyeSize = entity.radius * 0.15;
            
            // å³ç›®ï¼ˆé€²è¡Œæ–¹å‘å´ï¼‰
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(entity.radius * 0.3, -entity.radius * 0.3, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(entity.radius * 0.3, -entity.radius * 0.3, eyeSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // å·¦ç›®
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(entity.radius * 0.3, entity.radius * 0.3, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(entity.radius * 0.3, entity.radius * 0.3, eyeSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
        }

        // ã‚¿ã‚³æç”»
        function drawOctopus(ctx, entity) {
            if (entity.tentacles) {
                entity.tentacles.forEach(tentacle => {
                    ctx.save();
                    ctx.rotate(tentacle.angle);
                    ctx.strokeStyle = entity.color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(tentacle.length, 0);
                    ctx.stroke();
                    ctx.restore();
                });
            }
        }

        // ã‚¤ã‚«æç”»
        function drawSquid(ctx, entity) {
            // ä½“ã®å½¢çŠ¶
            ctx.fillStyle = entity.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, entity.radius, entity.radius * 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è§¦æ‰‹
            for (let i = 0; i < 8; i++) {
                ctx.save();
                ctx.rotate((i / 8) * Math.PI * 2);
                ctx.strokeStyle = entity.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, entity.radius);
                ctx.lineTo(0, entity.radius + 15);
                ctx.stroke();
                ctx.restore();
            }
        }

        // ã‚¯ãƒ©ã‚²æç”»
        function drawJellyfish(ctx, entity) {
            // å‚˜ã®éƒ¨åˆ†
            ctx.fillStyle = entity.color;
            ctx.beginPath();
            ctx.arc(0, -entity.radius * 0.3, entity.radius, 0, Math.PI, false);
            ctx.fill();
            
            // è§¦æ‰‹
            ctx.strokeStyle = entity.color;
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const x = (i - 2.5) * 6;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                for (let j = 0; j < 20; j += 2) {
                    const waveX = x + Math.sin(j * 0.3 + Date.now() * 0.01) * 3;
                    ctx.lineTo(waveX, j + 5);
                }
                ctx.stroke();
            }
        }

        // ã‚µãƒ¡æç”»
        function drawShark(ctx, entity) {
            // ä½“
            ctx.fillStyle = entity.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, entity.radius, entity.radius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // èƒŒã³ã‚Œ
            ctx.beginPath();
            ctx.moveTo(-entity.radius * 0.5, -entity.radius * 0.6);
            ctx.lineTo(-entity.radius * 0.2, -entity.radius * 1.2);
            ctx.lineTo(entity.radius * 0.2, -entity.radius * 0.6);
            ctx.fill();
            
            // å°»å°¾
            ctx.beginPath();
            ctx.moveTo(entity.radius, 0);
            ctx.lineTo(entity.radius * 1.5, -entity.radius * 0.4);
            ctx.lineTo(entity.radius * 1.3, 0);
            ctx.lineTo(entity.radius * 1.5, entity.radius * 0.4);
            ctx.fill();
        }

        // ãƒ’ãƒˆãƒ‡æç”»
        function drawStarfish(ctx, entity) {
            ctx.fillStyle = entity.color;
            ctx.beginPath();
            
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const x = Math.cos(angle) * entity.radius;
                const y = Math.sin(angle) * entity.radius;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // è…•ã®é–“ã®å‡¹ã¿
                const midAngle = ((i + 0.5) / 5) * Math.PI * 2;
                const midX = Math.cos(midAngle) * entity.radius * 0.5;
                const midY = Math.sin(midAngle) * entity.radius * 0.5;
                ctx.lineTo(midX, midY);
            }
            
            ctx.closePath();
            ctx.fill();
        }

        // åŸºæœ¬çš„ãªé­šæç”»
        function drawBasicFish(ctx, entity) {
            // å°»å°¾
            ctx.fillStyle = entity.color;
            ctx.beginPath();
            ctx.moveTo(entity.radius, 0);
            ctx.lineTo(entity.radius * 1.5, -entity.radius * 0.5);
            ctx.lineTo(entity.radius * 1.2, 0);
            ctx.lineTo(entity.radius * 1.5, entity.radius * 0.5);
            ctx.closePath();
            ctx.fill();
            
            // ã²ã‚Œ
            ctx.beginPath();
            ctx.ellipse(0, entity.radius * 0.7, entity.radius * 0.3, entity.radius * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // ç›®ã‚’æç”»
        function drawEyes(ctx, entity) {
            const eyeSize = entity.radius * 0.15;
            
            // å·¦ç›®
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-entity.radius * 0.3, -entity.radius * 0.3, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-entity.radius * 0.3, -entity.radius * 0.3, eyeSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // å³ç›®
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-entity.radius * 0.3, entity.radius * 0.3, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-entity.radius * 0.3, entity.radius * 0.3, eyeSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
        function drawPlayer(ctx) {
            const player = GameState.player;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // ç„¡æ•µæ™‚é–“ä¸­ã®ç‚¹æ»…åŠ¹æœ
            if (GameState.isInvincible) {
                const blink = Math.sin(Date.now() * 0.02) > 0;
                if (!blink) {
                    ctx.globalAlpha = 0.5;
                }
                
                // ç„¡æ•µã‚ªãƒ¼ãƒ©
                const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius + 20);
                auraGradient.addColorStop(0, 'rgba(255, 255, 0, 0.3)');
                auraGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius + 20, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // é­šã®å‘ãã«å›è»¢
            ctx.rotate(player.angle);
            
            // å…‰ã®ã‚ªãƒ¼ãƒ©
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius + 10);
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, player.radius + 10, 0, Math.PI * 2);
            ctx.fill();
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½“ï¼ˆæ¥•å††å½¢ã«ã—ã¦é­šã‚‰ã—ãï¼‰
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, player.radius, player.radius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å°»å°¾ï¼ˆé­šã®å¾Œã‚å´ï¼‰
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(-player.radius, 0);
            ctx.lineTo(-player.radius * 1.5, -player.radius * 0.4);
            ctx.lineTo(-player.radius * 1.2, 0);
            ctx.lineTo(-player.radius * 1.5, player.radius * 0.4);
            ctx.closePath();
            ctx.fill();
            
            // èƒŒã²ã‚Œ
            ctx.beginPath();
            ctx.moveTo(-player.radius * 0.3, -player.radius * 0.7);
            ctx.lineTo(-player.radius * 0.1, -player.radius * 1.1);
            ctx.lineTo(player.radius * 0.2, -player.radius * 0.7);
            ctx.fill();
            
            // è…¹ã²ã‚Œ
            ctx.beginPath();
            ctx.ellipse(-player.radius * 0.2, player.radius * 0.5, player.radius * 0.25, player.radius * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ç›®ï¼ˆé­šã®å‰å´ï¼‰
            const eyeSize = player.radius * 0.15;
            
            // å³ç›®ï¼ˆé€²è¡Œæ–¹å‘ã‹ã‚‰è¦‹ã¦ï¼‰
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.radius * 0.3, -player.radius * 0.25, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(player.radius * 0.3, -player.radius * 0.25, eyeSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // å·¦ç›®
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.radius * 0.3, player.radius * 0.25, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(player.radius * 0.3, player.radius * 0.25, eyeSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºï¼ˆå¸¸ã«æ°´å¹³ã«ï¼‰
            ctx.rotate(-player.angle); // å›è»¢ã‚’å…ƒã«æˆ»ã™
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeText(GameState.level, 0, 4);
            ctx.fillText(GameState.level, 0, 4);
            
            ctx.restore();
        }

        // UIåŠ¹æœæç”»
        function drawUIEffects(ctx) {
            // ä½é…¸ç´ è­¦å‘Š
            if (GameState.oxygen < 30) {
                ctx.save();
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
                ctx.fillStyle = 'red';
                ctx.fillRect(0, 0, elements.canvas.width, elements.canvas.height);
                ctx.restore();
            }
        }

        // UIæ›´æ–°
        function updateUI() {
            elements.scoreValue.textContent = GameState.score;
            elements.levelValue.textContent = GameState.level;
            elements.oxygenFill.style.width = GameState.oxygen + '%';
            elements.healthFill.style.width = GameState.player.health + '%';
            
            // ç„¡æ•µçŠ¶æ…‹è¡¨ç¤º
            if (GameState.isInvincible) {
                elements.invincibilityStatus.style.display = 'block';
            } else {
                elements.invincibilityStatus.style.display = 'none';
            }
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±æ›´æ–°
            const playerType = CreatureTypes[GameState.player.type] || { name: 'é­š', emoji: 'ğŸ ' };
            elements.playerInfo.textContent = `${playerType.emoji} ${playerType.name}`;
            
            // é…¸ç´ ãƒãƒ¼ã®è‰²å¤‰æ›´
            if (GameState.oxygen > 60) {
                elements.oxygenFill.style.background = 'linear-gradient(90deg, #00ff00, #90EE90)';
            } else if (GameState.oxygen > 30) {
                elements.oxygenFill.style.background = 'linear-gradient(90deg, #ffff00, #FFA500)';
            } else {
                elements.oxygenFill.style.background = 'linear-gradient(90deg, #ff0000, #FF6347)';
            }
            
            // ä½“åŠ›ãƒãƒ¼ã®è‰²å¤‰æ›´
            if (GameState.player.health > 70) {
                elements.healthFill.style.background = 'linear-gradient(90deg, #00ff00, #90EE90)';
            } else if (GameState.player.health > 30) {
                elements.healthFill.style.background = 'linear-gradient(90deg, #ffff00, #FFA500)';
            } else {
                elements.healthFill.style.background = 'linear-gradient(90deg, #ff0000, #FF6347)';
            }
        }

        // å…¥åŠ›å‡¦ç†
        function handleTap(e) {
            if (!GameState.gameRunning) return;
            
            e.preventDefault();
            
            const rect = elements.canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches[0]) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            GameState.player.targetX = clientX - rect.left;
            GameState.player.targetY = clientY - rect.top;
            
            // æ³¡åŠ¹æœ
            createBubble();
        }

        function handleTouchMove(e) {
            e.preventDefault();
        }

        function handleMouseMove(e) {
            if (!GameState.gameRunning) return;
            
            const rect = elements.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // ç”Ÿç‰©æƒ…å ±è¡¨ç¤º
            let hoveredCreature = null;
            GameState.entities.forEach(entity => {
                const dx = mouseX - entity.x;
                const dy = mouseY - entity.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < entity.radius + 10) {
                    hoveredCreature = entity;
                }
            });
            
            if (hoveredCreature) {
                const creatureType = CreatureTypes[hoveredCreature.type];
                elements.creatureInfo.innerHTML = `
                    <strong>${creatureType.emoji} ${creatureType.name}</strong><br>
                    ${creatureType.description}
                `;
                elements.creatureInfo.style.display = 'block';
                elements.creatureInfo.style.left = mouseX + 10 + 'px';
                elements.creatureInfo.style.top = mouseY - 50 + 'px';
            } else {
                elements.creatureInfo.style.display = 'none';
            }
        }

        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
        function gameOver() {
            GameState.gameRunning = false;
            
            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚’éè¡¨ç¤ºã«ã—ã¦ãƒªã‚»ãƒƒãƒˆ
            elements.joystick.style.display = 'none';
            GameState.joystick.active = false;
            elements.joystickKnob.classList.remove('active');
            GameState.joystick.knobX = 0;
            GameState.joystick.knobY = 0;
            GameState.joystick.inputX = 0;
            GameState.joystick.inputY = 0;
            elements.joystickKnob.style.left = '50%';
            elements.joystickKnob.style.top = '50%';
            
            // æˆæœã®è¨ˆç®—
            const achievements = [];
            if (GameState.score > 1000) achievements.push('ğŸ† å¤§å†’é™ºè€…');
            if (GameState.level >= 5) achievements.push('ğŸ–ï¸ æ·±æµ·æ¢æ¤œå®¶');
            if (GameState.player.radius > 30) achievements.push('ğŸ‹ æµ·ã®ç‹è€…');
            
            elements.finalScore.textContent = `ã‚¹ã‚³ã‚¢: ${GameState.score}`;
            elements.achievements.textContent = achievements.join(' ');
            elements.gameOverScreen.style.display = 'flex';
            
            if (GameState.animationId) {
                cancelAnimationFrame(GameState.animationId);
            }
        }

        // åˆæœŸåŒ–
        function init() {
            getDOMElements();
            resizeCanvas();
            setupEventListeners();
            
            // åˆæœŸæ³¡ã‚’ä½œæˆ
            for (let i = 0; i < 30; i++) {
                createBubble();
            }
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', init);
        window.addEventListener('load', init);
    </script>
</body>
</html>
